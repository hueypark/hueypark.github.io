<!DOCTYPE html>
<html lang="en-us">

<head>
<meta charset="utf-8" />
<meta name="author" content="" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

<link rel="canonical" href="https://marsettler.com/posts/2018-12-08-scheduling-in-go-part3/">
<meta property="og:title" content="(번역) Go 스케줄링 파트 3" />
<meta property="og:description" content="원문: https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html

프렐류드
Go 스케줄러의 구조와 의미 이해를 제공하는 3부작의 세 번째 글입니다. 이 글은 동시성에 중점을 둡니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://marsettler.com/posts/2018-12-08-scheduling-in-go-part3/" />
<meta property="article:published_time" content="2018-12-08T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-02-23T09:51:00+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="(번역) Go 스케줄링 파트 3"/>
<meta name="twitter:description" content="원문: https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html

프렐류드
Go 스케줄러의 구조와 의미 이해를 제공하는 3부작의 세 번째 글입니다. 이 글은 동시성에 중점을 둡니다."/>

<meta itemprop="name" content="(번역) Go 스케줄링 파트 3">
<meta itemprop="description" content="원문: https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html

프렐류드
Go 스케줄러의 구조와 의미 이해를 제공하는 3부작의 세 번째 글입니다. 이 글은 동시성에 중점을 둡니다.">
<meta itemprop="datePublished" content="2018-12-08T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-02-23T09:51:00&#43;09:00" />
<meta itemprop="wordCount" content="2671">



<meta itemprop="keywords" content="go,multithread," />

<link rel="stylesheet" href="/css/layout.css" />


<link rel="stylesheet" href="/css/default-dark.css" />


<link href="/font/d2coding.css" rel="stylesheet" type="text/css">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-121966234-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<title>


     (번역) Go 스케줄링 파트 3 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="https://marsettler.com/">Marsettler</a>
    </div> 

    <a class="nav-item" href="/tags"><div class="nav-item-title">Tags</div></a>
    
    
    <a class="nav-item" href="/wiki/"><div class="nav-item-title">Wiki</div></a>
    
    <a class="nav-item" href="/about-me/"><div class="nav-item-title">About Me</div></a>
    

  </nav>

  
<div class="social-links-header">

  
  <a href="mailto:jaewan.huey.park@gmail.com"><div class="social-link">email</div></a>
  

  
  <a href="https://github.com/hueypark" target="_blank"><div class="social-link">gh</div></a>
  

  

  
  <a href="https://twitter.com/jaewanHueyPark" target="_blank"><div class="social-link">twtr</div></a>
  

  

</div>


</div>


</header>


<article class="post">
    <h1 class="title"> (번역) Go 스케줄링 파트 3 </h1>
    <div class="content"> <p>원문: <a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html</a></p>
<hr>
<h3 id="heading">프렐류드</h3>
<p>Go 스케줄러의 구조와 의미 이해를 제공하는 3부작의 세 번째 글입니다. 이 글은 동시성에 중점을 둡니다.</p>
<p>세 시리즈의 인덱스:</p>
<ol>
<li><a href="/2018/10/02/scheduling-in-go-part1.html">(번역) Go 스케줄링 파트 3 - OS 스케줄러</a></li>
<li><a href="/2018/10/03/scheduling-in-go-part2.html">(번역) Go 스케줄링 파트 3 - Go 스케줄러</a></li>
<li><a href="/2018/12/08/scheduling-in-go-part3.html">(번역) Go 스케줄링 파트 3 - 동시성</a></li>
</ol>
<h3 id="heading1">서론</h3>
<p>저는 문제를 해결할 때, 특히 그 문제가 새로운 것일 경우 처음에는 동시성이 적합한지 아닌지에 대해 고려하지 않습니다. 먼저 순차적인 해결책을 찾아 작동하는지 확인하고, 다음 가독성과 기술검토를 거쳐 동시성이 합리적이고 실용적인지 질문합니다. 이 때 동시성이 적합한지 아닌지가 명확하게 드러납니다.</p>
<p>이 시리즈의 <a href="/2018/10/02/scheduling-in-go-part1.html">첫번째 파트</a>에서, 멀티쓰레드 코드를 작성에 중요한 의미를 가지는 OS 스케줄러의 구조와 의미에 대해 설명했습니다. <a href="/2018/10/03/scheduling-in-go-part2.html">두번째 파트</a>에서는 Go에서 동시성 코드를 작성하는데 중요한 의미를 자지는 Go 스케줄러에 대해 설명했습니다. 이 글에서는 OS와 Go 스케줄러의 구조와 의미를 결합하여 동시성에 대해 더 깊이 설명하겠습니다.</p>
<p>이 글의 목표는 다음과 같습니다.</p>
<ul>
<li>작업부하가 동시성을 제공하기 위해 적합한지 결정할 지침을 제공합니다.</li>
<li>다른 종류의 작업부하가 어떻게 동작하는지, 그에 따른 엔지니어링 의사결정은 어떻게 하는지 보여줍니다.</li>
</ul>
<h3 id="-">동시성이란 무엇입니까</h3>
<p>동시성은 &ldquo;순서를 지키지 않는&rdquo; 실행을 의미합니다. 그러기 위해서 일련의 명령어를 처리할 때 순차적으로 실행할 경우와 아닐 경우가 동일한 결과를 만들어내는 것을 보장해야 합니다. 여러분의 문제가 순서를 지키지 않는 실행이 가치 있을 만하다는 것이 분명해야 합니다. 이 때 가치는 복잡한 비용을 지불하더라도 충분한 성능향상이 일어나야 한다는 것입니다. 문제에 따라서는 순서를 지키지 않는 실행이 불가능하거나 말이 안 될 수도 있습니다.</p>
<p><a href="https://blog.golang.org/concurrency-is-not-parallelism">동시성과 병렬성이 다르다</a>는 것을 이해하는 것도 중요합니다. 병렬성은 두 개 이상의 명령어를 동시에 실행하는 것을 의미합니다. 이것은 동시성과는 다른 개념입니다. 병렬성은 2개 이상의 OS/하드웨어 쓰레드가 있고 독립적으로 명령을 수행하는 2개 이상의 고루틴을 가지고 있는 경우에만 가능합니다.</p>
<p><strong>그림1 : 동시성 vs 병렬성</strong>
<img src="/post/2018-12-08-scheduling-in-go-part3/concurrency-vs-parallelism.png" alt=""></p>
<p>그림 1에서 각각 독립적인 OS 쓰레드(M)이 독립적인 하드웨어 쓰레드(코어)에 연결된 두 개의 논리 프로세서(P)를 볼 수 있습니다. 두 개의 고루틴(G1과 G2)이 병렬 실행되고 있으며, 각각의 OS/하드웨어 쓰레드에서 명령을 병렬 실행하는 것을 볼 수 있습니다. 각 논리 프로세서 내에서 3개의 고루틴이 차례로 각 OS 쓰레드를 공유합니다. 이 고루틴들은 동시성을 가지며, 특정 순서없이 명령을 실행하고 OS 쓰레드 시간을 공유합니다.</p>
<p>이것이 문제입니다. 병렬 처리가 없는 동시성을 활용하면 처리가 실제로 느려질 수 있습니다. 또 흥미로운 것은 동시성을 병렬성과 함께 사용해도 생각보다 큰 성능 향상을 얻지 못할 수도 있습니다.</p>
<h3 id="heading2">작업부하</h3>
<p>순서를 지키지 않는 실행이 가능하고 의미있는 경우는 어떻게 알 수 있습니까? 작업부하의 유형을 이해하는 것은 좋은 방법입니다. 동시성을 생각할 때 중요한 두 종류의 작업부하가 있습니다.</p>
<ul>
<li>CPU 바운드: 고루틴이 자연스럽게 대기상태로 변경되지 않는 작업입니다. 지속적으로 연산을 수행합니다. 파이의 N번째 자릿수를 계산하는 쓰레드는 CPU 바운드가 됩니다.</li>
<li>IO 바운드: 고루틴이 자연스럽게 대기상태로 변경되는 작업입니다. 이 작업은 네트워크를 통해 리소스에 접근하거나, 운영체제의 시스템 호출을 하거나, 이벤트가 발생할 때까지 대기하고 있습니다. 파일을 읽는 고루틴은 IO 바운드입니다. 고루틴을 대기하게 하는 동기화 이벤트(뮤텍스, 아토믹)도 이 범주에 포함됩니다.</li>
</ul>
<p>CPU 바운드 작업에 동시성을 활용하려면 병렬 처리가 필요합니다. 고루틴이 자연스럽게 상태를 변경하지 못하기 때문에 여러 고루틴을 처리하는 단일 OS/하드웨어 쓰레드는 효율적이지 않습니다. OS/하드웨어 쓰레드보다 고루틴 수가 많으면 OS 쓰레드로 이동하고 다시 돌아오는 대기시간 때문에 실행속도가 느려질 수 있습니다. 컨텍스트 스위치는 작업부하에 대해 &ldquo;Stop The World&rdquo; 이벤트를 발생시킵니다. 스위치 중에는 어떤 작업도 실행될 수 없기 때문입니다.</p>
<p>IO 바운드 작업에 동시성을 사용하기 위해 병렬 처리는 필요하지 않습니다. 고루틴이 자연스럽게 상태를 변경하기 때문에 OS/하드웨서 쓰레드가 여러 고루틴을 효율적으로 처리할 수 있습니다. OS/하드웨어 쓰레드보다 고루틴이 많아도 컨텍스트 스위치가 &ldquo;Stop The World&rdquo; 이벤트를 발생시키지 않기 때문에 작업 속도가 빨라질 수 있습니다. 작업부하는 자연스럽게 멈추게 되고 이것은 OS/하드웨어 쓰레드를 대기상태로 두는 대신 다른 고루틴이 효율적으로 사용하게 합니다.</p>
<p>하드웨어당 쓰레드 당 고루틴이 얼마일때 최고의 처리량을 제공하는지 어떻게 알 수 있습니까? 고루틴이 너무 작으면 대기시간이 많습니다. 고루틴이 더무 많으면 컨텍스트 스위치 시간이 길어집니다. 이것은 이 글을 범위를 넘어서며 당신이 생각해야 하는 내용입니다.</p>
<p>지금은 작업부하가 동시성을 사용할 때 병렬처리가 필요한 경우를 확인하기 위해 약간의 코드를 살펴보겠습니다.</p>
<h3 id="-1">숫자 더하기</h3>
<p>이런 의미를 이해하고 시각화하기 위해 복잡한 코드는 필요하지 않습니다. 정수 컬렉션을 합하는 <code>add</code> 함수를 살펴보겠습니다.</p>
<p><strong>목록 1</strong>
<a href="https://play.golang.org/p/r9LdqUsEzEz">https://play.golang.org/p/r9LdqUsEzEz</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">36</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
<span style="color:#ae81ff">37</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">38</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">numbers</span> {
<span style="color:#ae81ff">39</span>         <span style="color:#a6e22e">v</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
<span style="color:#ae81ff">40</span>     }
<span style="color:#ae81ff">41</span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
<span style="color:#ae81ff">42</span> }
</code></pre></div><p>목록 1의 36번째 줄에서 <code>add</code> 함수가 선언되어 정수 컬렉션의 합을 반환합니다. 37번째 줄에서 <code>v</code> 변수를 선언합니다. 38번째 줄에서 컬렉션을 선형적으로 순회하여 39번째 줄에서 현재 합계에 더합니다. 마지막으로 41번째 줄은 최종 합계를 반환합니다.</p>
<p>질문: <code>add</code> 함수가 순서를 지키지 않는 실행에 적합한 작업입니까? 저는 그렇다고 생각합니다. 정수 컬렉션은 작은 목록으로 나뉘어 동시에 처리될 수 있습니다. 모든 작은 목록이 합해지면 합해진 목록을 모아 순차적인 버전과 동일한 결과를 만들 수 있습니다.</p>
<p>하지만, 또 다른 질문이 있습니다. 최고의 처리량을 얻으려면 몇 개의 작은 목록을 만들고 독립적으로 처리해야 합니까? 이 질문에 답하려면 <code>add</code> 함수에서 어떤 종류의 작업부하가 수행 중인지 알아야 합니다. <code>add</code> 함수는 순수한 수학 연산만 하고 자연스러운 대기상태에 들어가지 않기 때문에 CPU 바운드 작업입니다. 이는 처리량을 높이기 위해 OS/하드웨어 스레드 당 하나의 고루틴을 사용해야 하는 것을 의미합니다.</p>
<p>아래 목록 2는 동시성 버전의 <code>add</code>입니다.</p>
<p>참고: 동시성 버전의 <code>add</code>를 작성할 때 여러가지 방법이 있습니다. 저의 구현에 집착하지 마십시오. 만약 더 읽기 쉽고 성능이 좋은 버전을 가지고 있다면 공유바랍니다.</p>
<p><strong>목록 2</strong>
<a href="https://play.golang.org/p/r9LdqUsEzEz">https://play.golang.org/p/r9LdqUsEzEz</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">44</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">addConcurrent</span>(<span style="color:#a6e22e">goroutines</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
<span style="color:#ae81ff">45</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int64</span>
<span style="color:#ae81ff">46</span>     <span style="color:#a6e22e">totalNumbers</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">numbers</span>)
<span style="color:#ae81ff">47</span>     <span style="color:#a6e22e">lastGoroutine</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">goroutines</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">48</span>     <span style="color:#a6e22e">stride</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">totalNumbers</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">goroutines</span>
<span style="color:#ae81ff">49</span>
<span style="color:#ae81ff">50</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#ae81ff">51</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">goroutines</span>)
<span style="color:#ae81ff">52</span>
<span style="color:#ae81ff">53</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">g</span> &lt; <span style="color:#a6e22e">goroutines</span>; <span style="color:#a6e22e">g</span><span style="color:#f92672">++</span> {
<span style="color:#ae81ff">54</span>         <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">g</span> <span style="color:#66d9ef">int</span>) {
<span style="color:#ae81ff">55</span>             <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">stride</span>
<span style="color:#ae81ff">56</span>             <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">stride</span>
<span style="color:#ae81ff">57</span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">lastGoroutine</span> {
<span style="color:#ae81ff">58</span>                 <span style="color:#a6e22e">end</span> = <span style="color:#a6e22e">totalNumbers</span>
<span style="color:#ae81ff">59</span>             }
<span style="color:#ae81ff">60</span>
<span style="color:#ae81ff">61</span>             <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lv</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">62</span>             <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">end</span>] {
<span style="color:#ae81ff">63</span>                 <span style="color:#a6e22e">lv</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
<span style="color:#ae81ff">64</span>             }
<span style="color:#ae81ff">65</span>
<span style="color:#ae81ff">66</span>             <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, int64(<span style="color:#a6e22e">lv</span>))
<span style="color:#ae81ff">67</span>             <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
<span style="color:#ae81ff">68</span>         }(<span style="color:#a6e22e">g</span>)
<span style="color:#ae81ff">69</span>     }
<span style="color:#ae81ff">70</span>
<span style="color:#ae81ff">71</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
<span style="color:#ae81ff">72</span>
<span style="color:#ae81ff">73</span>     <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">v</span>)
<span style="color:#ae81ff">74</span> }
</code></pre></div><p>목록2에서 <code>add</code> 함수의 동시성 버전인 <code>addConcurrent</code>가 제공됩니다. 순차 버전이 5줄의 코드를 사용하는 것과 달리 동시성 버전은 26줄의 코드를 사용합니다. 많은 코드가 있으므로 중요한 줄만 설명하겠습니다.</p>
<p>줄 48: 각 고루틴은 고유하지만 적은 수의 목록을 가집니다. 목록의 크기는 컬렉션의 크기를 고루틴의 수로 나눈 값입니다.</p>
<p>줄 53: 작업을 하기 위해 고루틴 풀이 생성됩니다.</p>
<p>줄 57-59: 마지막 고루틴은 다른 고루틴에서 작업하지 않은 나머지 숫자 목록을 더하게 됩니다.</p>
<p>줄 66: 작은 목록의 합이 최종 결과로 더해집니다.</p>
<p>동시성 버전은 순차 버전보다 확실히 복잡합니다. 하지만 가치 있는 일입니까? 이 질문에 답하는 가장 좋은 방법은 벤치마크를 작성하는 것입니다. 저는 가비지 컬렉터가 꺼진 상태에서 1,000만 개의 콜렉션을 사용했습니다. <code>add</code> 함수를 사용하는 순차 버전과 <code>addConcurrent</code> 함수를 사용하는 동시성 버전이 있습니다.</p>
<p><strong>목록 3</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkSequential</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">numbers</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkConcurrent</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">addConcurrent</span>(<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">NumCPU</span>(), <span style="color:#a6e22e">numbers</span>)
    }
}
</code></pre></div><p>목록 3은 벤치마크 함수를 보여줍니다. 다음은 모든 고루틴이 단일 OS/하드웨어 쓰레드만 사용할 수 있는 경우 결과입니다. 순차버전은 1개의 고루틴을 사용하고, 동시성 버전은 8개의 고루틴을 사용하고 있습니다. 이 경우 동시성 버전은 병렬처리 없이 동시성을 사용합니다.</p>
<p><strong>목록 4</strong></p>
<pre><code>10 Million Numbers using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITHOUT Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 1 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound
BenchmarkSequential      	    1000	   5720764 ns/op : ~10% Faster
BenchmarkConcurrent      	    1000	   6387344 ns/op
BenchmarkSequentialAgain 	    1000	   5614666 ns/op : ~13% Faster
BenchmarkConcurrentAgain 	    1000	   6482612 ns/op
</code></pre><p>참고: 로컬 컴퓨터에서 벤치마크를 하는 것에는 많은 고려사항이 있습니다. 이 상황에는 벤치마크가 부정확할 수 있는 요인이 많습니다. 최대한 장비가 대기상태임을 확인하고 벤치마크를 여러 번 실행하십시오. 결과에 일관성이 있는지 확인이 필요합니다. 테스트 도구로 벤치마크를 두 번 실행하면 일관된 결과를 얻을 수 있습니다.</p>
<p>목록 4의 벤치마크는 고루틴이 하나의 OS/하드웨어 쓰레드만 사용할 수 있는 경우 순차 버전이 동시성 버전보다 10~13% 빠른 걸 보여줍니다. 이것은 동시성 버전이 단일 OS 쓰레드의 컨텍스트 스위치와 고루틴 관리에서 오버헤드를 가지기 때문에 예상할 수 있었던 결과입니다.</p>
<p>다음은 OS/하드웨어 쓰레드가 각 고루틴에서 사용가능한 경우의 결과입니다. 제 장비에서 순차 버전은 1개의 고루틴을 사용하며 동시성 버전은 8개의 고루틴을 사용하고 있습니다. 이 경우 동시성 버전은 병렬성을 사용합니다.</p>
<p><strong>목록 5</strong></p>
<pre><code>10 Million Numbers using 8 goroutines with 8 cores
2.9 GHz Intel 4 Core i7
Concurrency WITH Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 8 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/cpu-bound
BenchmarkSequential-8        	    1000	   5910799 ns/op
BenchmarkConcurrent-8        	    2000	   3362643 ns/op : ~43% Faster
BenchmarkSequentialAgain-8   	    1000	   5933444 ns/op
BenchmarkConcurrentAgain-8   	    2000	   3477253 ns/op : ~41% Faster
</code></pre><p>목록 5의 벤치마크에서 고루틴에 대해 개별 OS/하드웨어 쓰레드를 사용할 경우 동시성 버전이 순차 버전보다 41~43% 빠릅니다. 이것은 모든 고루틴이 병렬로 실행되기 때문입니다. 동시에 8개의 고루틴이 작업을 수행합니다.</p>
<h3 id="heading3">정렬</h3>
<p>모든 CPU 바인딩 작업이 동시성에 적합하지 않다는 것을 이해하는 것이 중요합니다. 주로 작업을 중단하거나 결과를 합하는 데 많은 비용이 들 때 이는 사실입니다. 대표적인 사례는 버블소트입니다. Go에서 버블소트를 구현한 다음 코드를 보십시오.</p>
<p><strong>목록 6</strong>
<a href="https://play.golang.org/p/S0Us1wYBqG6">https://play.golang.org/p/S0Us1wYBqG6</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">01</span> <span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#ae81ff">02</span>
<span style="color:#ae81ff">03</span> <span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
<span style="color:#ae81ff">04</span>
<span style="color:#ae81ff">05</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">int</span>) {
<span style="color:#ae81ff">06</span>     <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">numbers</span>)
<span style="color:#ae81ff">07</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
<span style="color:#ae81ff">0</span><span style="color:#ae81ff">8</span>         <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">sweep</span>(<span style="color:#a6e22e">numbers</span>, <span style="color:#a6e22e">i</span>) {
<span style="color:#ae81ff">0</span><span style="color:#ae81ff">9</span>             <span style="color:#66d9ef">return</span>
<span style="color:#ae81ff">10</span>         }
<span style="color:#ae81ff">11</span>     }
<span style="color:#ae81ff">12</span> }
<span style="color:#ae81ff">13</span>
<span style="color:#ae81ff">14</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sweep</span>(<span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">currentPass</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
<span style="color:#ae81ff">15</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">idx</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">16</span>     <span style="color:#a6e22e">idxNext</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">idx</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">17</span>     <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">numbers</span>)
<span style="color:#ae81ff">18</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">swap</span> <span style="color:#66d9ef">bool</span>
<span style="color:#ae81ff">19</span>
<span style="color:#ae81ff">20</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">idxNext</span> &lt; (<span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">currentPass</span>) {
<span style="color:#ae81ff">21</span>         <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">idx</span>]
<span style="color:#ae81ff">22</span>         <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">idxNext</span>]
<span style="color:#ae81ff">23</span>         <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> &gt; <span style="color:#a6e22e">b</span> {
<span style="color:#ae81ff">24</span>             <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">idx</span>] = <span style="color:#a6e22e">b</span>
<span style="color:#ae81ff">25</span>             <span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">idxNext</span>] = <span style="color:#a6e22e">a</span>
<span style="color:#ae81ff">26</span>             <span style="color:#a6e22e">swap</span> = <span style="color:#66d9ef">true</span>
<span style="color:#ae81ff">27</span>         }
<span style="color:#ae81ff">28</span>         <span style="color:#a6e22e">idx</span><span style="color:#f92672">++</span>
<span style="color:#ae81ff">29</span>         <span style="color:#a6e22e">idxNext</span> = <span style="color:#a6e22e">idx</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">30</span>     }
<span style="color:#ae81ff">31</span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">swap</span>
<span style="color:#ae81ff">32</span> }
<span style="color:#ae81ff">33</span>
<span style="color:#ae81ff">34</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
<span style="color:#ae81ff">35</span>     <span style="color:#a6e22e">org</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>}
<span style="color:#ae81ff">36</span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">org</span>)
<span style="color:#ae81ff">37</span>
<span style="color:#ae81ff">38</span>     <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#a6e22e">org</span>)
<span style="color:#ae81ff">39</span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">org</span>)
<span style="color:#ae81ff">40</span> }
</code></pre></div><p>목록 6에는 Go로 작성된 버블소트가 있습니다. 이 정렬 알고리즘은 모든 컬렉션을 순회하며 모든 경로에서 값을 교환합니다. 목록의 정렬 정도에 따라 모든 항목을 정렬하기 위해 컬렉션을 여러 번 순회할 수 있습니다.</p>
<p>질문: <code>bubbleSort</code> 함수는 순서가 보장되지 않는 실행에 적합한 작업입니까? 저는 아니라고 생각합니다. 정수 컬렉션은 작은 목록으로 나뉘어 동시에 정렬할 수 있습니다. 하지만 모든 작업이 완료된 후 작은 목록을 함께 정렬하는 효율적인 방법은 없습니다. 다음은 동시성 버전의 버블소트입니다.</p>
<p><strong>목록 8</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">01</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bubbleSortConcurrent</span>(<span style="color:#a6e22e">goroutines</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">numbers</span> []<span style="color:#66d9ef">int</span>) {
<span style="color:#ae81ff">02</span>     <span style="color:#a6e22e">totalNumbers</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">numbers</span>)
<span style="color:#ae81ff">03</span>     <span style="color:#a6e22e">lastGoroutine</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">goroutines</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
<span style="color:#ae81ff">04</span>     <span style="color:#a6e22e">stride</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">totalNumbers</span> <span style="color:#f92672">/</span> <span style="color:#a6e22e">goroutines</span>
<span style="color:#ae81ff">05</span>
<span style="color:#ae81ff">06</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#ae81ff">07</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">goroutines</span>)
<span style="color:#ae81ff">0</span><span style="color:#ae81ff">8</span>
<span style="color:#ae81ff">0</span><span style="color:#ae81ff">9</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">g</span> &lt; <span style="color:#a6e22e">goroutines</span>; <span style="color:#a6e22e">g</span><span style="color:#f92672">++</span> {
<span style="color:#ae81ff">10</span>         <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">g</span> <span style="color:#66d9ef">int</span>) {
<span style="color:#ae81ff">11</span>             <span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">stride</span>
<span style="color:#ae81ff">12</span>             <span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">start</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">stride</span>
<span style="color:#ae81ff">13</span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">lastGoroutine</span> {
<span style="color:#ae81ff">14</span>                 <span style="color:#a6e22e">end</span> = <span style="color:#a6e22e">totalNumbers</span>
<span style="color:#ae81ff">15</span>             }
<span style="color:#ae81ff">16</span>
<span style="color:#ae81ff">17</span>             <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#a6e22e">numbers</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">end</span>])
<span style="color:#ae81ff">18</span>             <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
<span style="color:#ae81ff">19</span>         }(<span style="color:#a6e22e">g</span>)
<span style="color:#ae81ff">20</span>     }
<span style="color:#ae81ff">21</span>
<span style="color:#ae81ff">22</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
<span style="color:#ae81ff">23</span>
<span style="color:#ae81ff">24</span>     <span style="color:#75715e">// Ugh, we have to sort the entire list again.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">25</span>     <span style="color:#a6e22e">bubbleSort</span>(<span style="color:#a6e22e">numbers</span>)
<span style="color:#ae81ff">26</span> }
</code></pre></div><p>목록 8에서 <code>bubbleSortConcurrent</code> 함수는 <code>bubbleSort</code> 함수의 동시성 버전입니다. 이것은 여러 고루틴을 사용하여 목록의 일부를 동시에 정렬합니다. 하지만 남은 것은 분할되어 정렬된 값 목록입니다. 전체 목록이 정렬되어 있지 않으면 24번 째 줄에서 다시 한 번 정렬해야 합니다.</p>
<p><strong>목록 9</strong></p>
<pre><code>Before:
  25 51 15 57 87 10 10 85 90 32 98 53
  91 82 84 97 67 37 71 94 26  2 81 79
  66 70 93 86 19 81 52 75 85 10 87 49

After:
  10 10 15 25 32 51 53 57 85 87 90 98
   2 26 37 67 71 79 81 82 84 91 94 97
  10 19 49 52 66 70 75 81 85 86 87 93
</code></pre><p>버블소트는 목록을 순회하면 교체하므로 25번 째 줄의 <code>bubbleSort</code> 호출은 동시성 사용으로 인한 잠재적 이득을 무효화합니다. 버블소트에서는 동시성을 사용하여 성능을 향상시킬 수 없습니다.</p>
<h3 id="-2">파일 읽기</h3>
<p>두 개의 CPU 바운드 작업부하를 살펴보았는데, IO 바운드 작업부하는 어떨 것 같습니까? 고루틴이 자연스럽데 대기상태로 변화될 때는 의미가 다른가요? 파일을 읽고 텍스트를 검색하는 IO 바운드 작업부하를 살펴보겠습니다.</p>
<p>첫 번째 버전은 <code>find</code>라는 함수의 순차적인 버전입니다.</p>
<p><strong>목록 10</strong>
<a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">42</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">topic</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">docs</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
<span style="color:#ae81ff">43</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">found</span> <span style="color:#66d9ef">int</span>
<span style="color:#ae81ff">44</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">docs</span> {
<span style="color:#ae81ff">45</span>         <span style="color:#a6e22e">items</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">doc</span>)
<span style="color:#ae81ff">46</span>         <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
<span style="color:#ae81ff">47</span>             <span style="color:#66d9ef">continue</span>
<span style="color:#ae81ff">48</span>         }
<span style="color:#ae81ff">49</span>         <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">item</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">items</span> {
<span style="color:#ae81ff">50</span>             <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Description</span>, <span style="color:#a6e22e">topic</span>) {
<span style="color:#ae81ff">51</span>                 <span style="color:#a6e22e">found</span><span style="color:#f92672">++</span>
<span style="color:#ae81ff">52</span>             }
<span style="color:#ae81ff">53</span>         }
<span style="color:#ae81ff">54</span>     }
<span style="color:#ae81ff">55</span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">found</span>
<span style="color:#ae81ff">56</span> }
</code></pre></div><p>목록 10에 순차적인 버전의 <code>find</code> 함수가 있습니다. 43번 째 줄에 <code>found</code>라는 변수가 선언되어 문서 안에 <code>topic</code>이 발견된 횟수를 기록합니다. 다음 44번 째 줄에서 문서를 반복하고 45번 째 줄에서 일기 기능을 사용하여 읽습니다. 마지막으로 49-53 줄에서 <code>strings</code> 패키지의 <code>Contains</code> 함수는 문서에서 읽은 아이템들의 컬렉션 안에 <code>topic</code>이 있는지 확인합니다. <code>topic</code>이 발견되면 <code>found</code>가 1씩 증가합니다.</p>
<p>다음은 <code>find</code>가 호출하는 <code>read</code> 함수의 구현입니다.</p>
<p><strong>목록 11</strong>
<a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">33</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">doc</span> <span style="color:#66d9ef">string</span>) ([]<span style="color:#a6e22e">item</span>, <span style="color:#66d9ef">error</span>) {
<span style="color:#ae81ff">34</span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>) <span style="color:#75715e">// Simulate blocking disk read.
</span><span style="color:#75715e"></span><span style="color:#ae81ff">35</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">document</span>
<span style="color:#ae81ff">36</span>     <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">xml</span>.<span style="color:#a6e22e">Unmarshal</span>([]byte(<span style="color:#a6e22e">file</span>), <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">d</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
<span style="color:#ae81ff">37</span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
<span style="color:#ae81ff">38</span>     }
<span style="color:#ae81ff">39</span>     <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Channel</span>.<span style="color:#a6e22e">Items</span>, <span style="color:#66d9ef">nil</span>
<span style="color:#ae81ff">40</span> }
</code></pre></div><p>목록 11의 <code>read</code> 함수는 1 밀리초 동안의 <code>time.Sleep</code> 호출로 시작합니다. 이것은 실제 시스템 호출을 수행하여 디스크에서 문서를 읽는 경우 발생하는 대기시간을 연출하는데 사용됩니다. 이 대기시간의 일관성은 동시성 버전과 순차적 버전에 대한 <code>find</code> 성능을 측정하는 데 중요합니다. 다음으로 35-59 행에서 전역변수 <code>file</code>에 저장된 모의 XML 문서를 언마샬합니다. 마지막으로 39행에서 아이템 컬렉션이 반환됩니다.</p>
<p>다음으로 동시성 버전입니다.</p>
<p>참고: 동시성 버전의 <code>find</code>를 작성하는 여러 방법이 있습니다. 저의 특정한 구현에 집착하지 마십시오. 만약 더 읽기 쉽고 성능이 좋은 버전을 가지고 있다면 공유바랍니다.</p>
<p><strong>목록 12</strong>
<a href="https://play.golang.org/p/8gFe5F8zweN">https://play.golang.org/p/8gFe5F8zweN</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ae81ff">58</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">findConcurrent</span>(<span style="color:#a6e22e">goroutines</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">topic</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">docs</span> []<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">int</span> {
<span style="color:#ae81ff">59</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">found</span> <span style="color:#66d9ef">int64</span>
<span style="color:#ae81ff">60</span>
<span style="color:#ae81ff">61</span>     <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>, len(<span style="color:#a6e22e">docs</span>))
<span style="color:#ae81ff">62</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">docs</span> {
<span style="color:#ae81ff">63</span>         <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">doc</span>
<span style="color:#ae81ff">64</span>     }
<span style="color:#ae81ff">65</span>     close(<span style="color:#a6e22e">ch</span>)
<span style="color:#ae81ff">66</span>
<span style="color:#ae81ff">67</span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
<span style="color:#ae81ff">68</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">goroutines</span>)
<span style="color:#ae81ff">69</span>
<span style="color:#ae81ff">70</span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">g</span> &lt; <span style="color:#a6e22e">goroutines</span>; <span style="color:#a6e22e">g</span><span style="color:#f92672">++</span> {
<span style="color:#ae81ff">71</span>         <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
<span style="color:#ae81ff">72</span>             <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">lFound</span> <span style="color:#66d9ef">int64</span>
<span style="color:#ae81ff">73</span>             <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">doc</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
<span style="color:#ae81ff">74</span>                 <span style="color:#a6e22e">items</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">read</span>(<span style="color:#a6e22e">doc</span>)
<span style="color:#ae81ff">75</span>                 <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
<span style="color:#ae81ff">76</span>                     <span style="color:#66d9ef">continue</span>
<span style="color:#ae81ff">77</span>                 }
<span style="color:#ae81ff">78</span>                 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">item</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">items</span> {
<span style="color:#ae81ff">79</span>                     <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">Description</span>, <span style="color:#a6e22e">topic</span>) {
<span style="color:#ae81ff">80</span>                         <span style="color:#a6e22e">lFound</span><span style="color:#f92672">++</span>
<span style="color:#ae81ff">81</span>                     }
<span style="color:#ae81ff">82</span>                 }
<span style="color:#ae81ff">83</span>             }
<span style="color:#ae81ff">84</span>             <span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">AddInt64</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">found</span>, <span style="color:#a6e22e">lFound</span>)
<span style="color:#ae81ff">85</span>             <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
<span style="color:#ae81ff">86</span>         }()
<span style="color:#ae81ff">87</span>     }
<span style="color:#ae81ff">88</span>
<span style="color:#ae81ff">89</span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
<span style="color:#ae81ff">90</span>
<span style="color:#ae81ff">91</span>     <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">found</span>)
<span style="color:#ae81ff">92</span> }
</code></pre></div><p>목록 12에서 <code>find</code> 함수의 동시성 버전인 <code>findConcurrent</code>가 제공됩니다. 순차 버전은 13행이지만 동시성 버전은 30행입니다. 동시성 버전의 구현목표는 예상할 수 없는 문서 수를 처리하는데 사용되는 고루틴의 수를 제어하는 것이었습니다. 고루틴 풀에 피드하는 채널을 사용하는 풀링 패턴이 제 선택이었습니다.</p>
<p>많은 코드가 있으므로 중요한 줄만 강조하겠습니다.</p>
<p>줄 61-64: 채널이 생성되고 처리해야 할 문서가 채워집니다.</p>
<p>줄 65: 문서가 모두 처리되면 고루틴 풀이 자연스럽게 종료되도록 채널이 닫힙니다.</p>
<p>줄 70: 고루틴 풀이 생성됩니다.</p>
<p>줄 73-83: 풀의 각 고루틴은 채널에서 문서를 수신하고 메모리로 읽어들여 내용을 확인합니다. 만약 일치하는 내용이 있으면 <code>lFound</code>는 증가합니다.</p>
<p>줄 84: 개별 고루틴의 결과가 최종적으로 합해집니다.</p>
<p>동시성 버전은 순차 버전보다 확실히 복잡합니다. 그럼 이것의 가치는 어떠합니까? 이 질문에 대답하는 가장 좋은 방법은 벤치마크를 만드는 것입니다. 벤치마크를 위해 가비지 컬렉터가 꺼진 채로 1000개의 문서를 사용했습니다. 순차 버전인 <code>find</code>와 동시성 버전인 <code>findConcurrent</code>가 있습니다.</p>
<p><strong>목록 13</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkSequential</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">find</span>(<span style="color:#e6db74">&#34;test&#34;</span>, <span style="color:#a6e22e">docs</span>)
    }
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkConcurrent</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#a6e22e">findConcurrent</span>(<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">NumCPU</span>(), <span style="color:#e6db74">&#34;test&#34;</span>, <span style="color:#a6e22e">docs</span>)
    }
}
</code></pre></div><p>목록 13은 벤치마크 함수를 보여줍니다. 아래는 단일 OS/하드웨어 쓰레드를 사용할 경우의 결과입니다. 순차 버전은 하나의 고루틴을 사용하고 공시성 버전은 내 컴퓨터에서 8개의 고루틴을 사용하고 있습니다. 이 경우 동시성 버전은 병렬 처리없이 동시성을 활용합니다.</p>
<p><strong>목록 14</strong></p>
<pre><code>10 Thousand Documents using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITHOUT Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -cpu 1 -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/io-bound
BenchmarkSequential      	       3	1483458120 ns/op
BenchmarkConcurrent      	      20	 188941855 ns/op : ~87% Faster
BenchmarkSequentialAgain 	       2	1502682536 ns/op
BenchmarkConcurrentAgain 	      20	 184037843 ns/op : ~88% Faster
</code></pre><p>목록 14의 벤치마크 결과에 따르면 고루틴이 단일 OS/하드웨어 쓰레드만 사용할 수 있는 경우 동시성 버전은 순차 버전보다 약 77-88% 빠릅니다. 이것은 고루틴이 단일 OS/하드웨어 쓰레드를 효율적으로 공유하기 떄문에 기대했던 결과와 같습니다. <code>read</code> 호출에서 각 고루틴에 발생시키는 자연스러운 컨텍스트 스위칭은 단일 OS/하드웨어 쓰레드에서 더 많은 작업을 수행할 수 있게 합니다.</p>
<p>다음은 병렬성을 이용해 동시성을 사용할 때의 벤치마크입니다.</p>
<p><strong>목록 15</strong></p>
<pre><code>10 Thousand Documents using 8 goroutines with 1 core
2.9 GHz Intel 4 Core i7
Concurrency WITH Parallelism
-----------------------------------------------------------------------------
$ GOGC=off go test -run none -bench . -benchtime 3s
goos: darwin
goarch: amd64
pkg: github.com/ardanlabs/gotraining/topics/go/testing/benchmarks/io-bound
BenchmarkSequential-8        	       3	1490947198 ns/op
BenchmarkConcurrent-8        	      20	 187382200 ns/op : ~88% Faster
BenchmarkSequentialAgain-8   	       3	1416126029 ns/op
BenchmarkConcurrentAgain-8   	      20	 185965460 ns/op : ~87% Faster
</code></pre><p>목록 15의 벤치마크에서 추가 OS/하드웨어 쓰레드가 성능을 향상시키지 않는다는 것을 알 수 있습니다.</p>
<h3 id="heading4">결론</h3>
<p>이 글의 목표는 작업부하가 동시성 사용에 적합한 지 여부를 결정하기 위해 고려해야 할 것에 대한 지침의 제공이었습니다. 저는 다른 유형의 알고리즘과 작업부하에 대한 예제를 제공하여 의미적인 차이와 엔지니어링 결정에서 고려되어야 할 부분에 대해 안내했습니다.</p>
<p>IO 바운드 작업부하에서 병렬 처리가 성능에 큰 영향을 주지 않는다는 것을 분명하게 알 수 있습니다. CPU 바운드 작업에서는 그 반대입니다. 버블 정렬과 같은 알고리즘의 경우에 동시성을 사용하면 성능의 이득없이 복잡도만 추가됩니다. 작업부하가 동시성에 적합한지 확인하고 어떤 의미를 가지는지 아는 것이 중요합니다.</p> </div>
    <footer class="post-footer">
  <div class="post-footer-data">
    
<div class="tags">
  
    
      <div class="tag">
        <a href="/tags/go">#go</a>
      </div>
    
      <div class="tag">
        <a href="/tags/multithread">#multithread</a>
      </div>
    
  
</div>

    <div class="date">created: 2018-12-08 | updated: 2020-02-23</div>
    
  </div>
</footer>

<script src="https://utteranc.es/client.js"
        repo="hueypark/wiki"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:jaewan.huey.park@gmail.com"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/hueypark" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  
  <a href="https://twitter.com/jaewanHueyPark" target="_blank"><div class="social-link">Twitter</div></a>
  

  

  <div class="social-link">
  <a href="https://marsettler.com/index.xml" target="_blank">RSS</a>
  </div>

</div>

  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>


  <div class="copyright">  </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

<script async src="/js/mermaid/mermaid.min.js"></script>

</body>
</html>

