<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MongoDB on Marsettler</title>
    <link>https://marsettler.com/tags/mongodb/</link>
    <description>Recent content in MongoDB on Marsettler</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 06 Mar 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://marsettler.com/tags/mongodb/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MongoDB 스터디 8주차(MongoDB CURD 맵 리듀스)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-8map-reduce/</link>
      <pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-8map-reduce/</guid>
      <description>Map-Reduce MongoDB 는 맵리듀스 대신 어그리게이션 파이프라인을 사용하길 권장하고 있으며, 상세내용은 아래와 같습니다.
어그리게이션 파이프라이프라인으로 맵 리듀스를 대체할 수 있습니다
어그리게이션 파이프라인은 맵-리듀스보다 좋은 성능과 사용성을 제공하며, $group, $merge와 같은 명령어를 사용해 맵리듀스를 어그리게이션 파이프라인으로 변경할 수 있습니다.
또 사용자 정의 기능이 필요한 경우 4.4 버전부터 $accumulator, $function 명렁어로 해결할 수 있습니다.
맵리듀스를 대체하는 어그리게이션 파이프라인을 알고 싶으면, 맵리듀스에서 어그리게이션 파이프라인으로 변경 나 맵리듀스 예제 문서를 참고하십시오.
참고자료  공식 문서 Map-Reduce  </description>
    </item>
    
    <item>
      <title>MongoDB 스터디 7주차(MongoDB CURD 읽기 연산)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-7/</link>
      <pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-7/</guid>
      <description>db.collection.find() 쿼리 기준과 일치하는 도큐먼트에 대한 커서를 반환합니다.
파라미터  query: 필터에 사용할 쿼리 연산자입니다. projection: 도큐먼트에서 반환할 필드를 지정합니다. 생략하면 모든 필드가 반환됩니다.  db.collection.findOne() 쿼리 기준과 일치하는 하나의 도큐먼트를 반환합니다. 여러 도큐먼트들이 쿼리를 만족하면 디스크에 저장된 순서에 따라 첫 도큐먼트를 반환합니다. 만약 대상이 없으면 null을 반환합니다.
Read Concern readConcern 옵션을 사용해 읽기 작업의 일관성과 격리수준, 가용성을 제어할 수 있습니다.
4.4 버전부터 기본값의 전역 설정이 가능합니다. 세부정보는 setDefaultRWConcern에서 확인하십시오.</description>
    </item>
    
    <item>
      <title>MongoDB 스터디 6주차(MongoDB CURD 쓰기 연산)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-6/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-6/</guid>
      <description>Create Operations db.collection.insertOne() 도큐먼트를 하나 추가합니다.
문법 db.collection.insertOne(&amp;lt;document&amp;gt;,{writeConcern: &amp;lt;document&amp;gt;}) writeConcern  w: 몇 개의 mongod 에 저장 후 응답할 지 설정  &amp;lt;숫자&amp;gt;: 몇 개의 mongod 에 기록될 지 직접 지정 &amp;ldquo;majority&amp;rdquo;: 과반의 mongod 에 기록되게 설정 &amp;lt;커스텀 write concern 이름&amp;gt;: 특정 데이터 센터에 저장되게 설정가능, Custom Multi-Datacenter Write Concerns   j: 디스크의 저널에 저장 후 응답할지 설정 여부 timeout: 쓰기 제한 시간(밀리세컨드), 반환하기 전에 이미 성공한 쓰기 작업을 롤백하지 않음    예 db.</description>
    </item>
    
    <item>
      <title>MongoDB 스터디 5주차(패턴과 안티패턴)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-5/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-5/</guid>
      <description>패턴 Attribute Pattern  상황  비슷한 필드가 많을 때 여러 필드에 걸쳐 조회하고 싶을때 필드가 일부 도큐먼트에만 있을 때   해결책  필드를 k/v 짝으로 나누어 서브도큐먼트에 저장   예  적용 전
{ &amp;#34;title&amp;#34;: &amp;#34;Star Wars&amp;#34;, &amp;#34;release_US&amp;#34;: &amp;#34;1977-05-20T01:00:00+01:00&amp;#34;, &amp;#34;release_France&amp;#34;: &amp;#34;1977-10-19T01:00:00+01:00&amp;#34;, &amp;#34;release_Italy&amp;#34;: &amp;#34;1977-10-20T01:00:00+01:00&amp;#34;, &amp;#34;release_UK&amp;#34;: &amp;#34;1977-12-27T01:00:00+01:00&amp;#34;, } 적용 후
{ &amp;#34;title&amp;#34;: &amp;#34;Star Wars&amp;#34;, &amp;#34;director&amp;#34;: &amp;#34;George Lucas&amp;#34;, &amp;#34;releases&amp;#34;: [ { &amp;#34;location&amp;#34;: &amp;#34;USA&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1977-05-20T01:00:00+01:00&amp;#34; }, { &amp;#34;location&amp;#34;: &amp;#34;France&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1977-10-19T01:00:00+01:00&amp;#34; }, { &amp;#34;location&amp;#34;: &amp;#34;Italy&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1977-10-20T01:00:00+01:00&amp;#34; }, { &amp;#34;location&amp;#34;: &amp;#34;UK&amp;#34;, &amp;#34;date&amp;#34;: &amp;#34;1977-12-27T01:00:00+01:00&amp;#34; }, ] }  장점  인덱싱하기 쉬움 더 적은 인덱스가 필요함 쿼리가 간단해지고 일반적으로 빨라짐    Extended Reference Pattern  상황  너무 많은 조인이 발생함   해결책  주가 되는 도큐먼트에 쪽에 필드를 임베딩함   예  적용 전</description>
    </item>
    
    <item>
      <title>MongoDB 스터디 3주차(샤딩을 통한 시스템 확장)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-3/</link>
      <pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-3/</guid>
      <description>샤딩 샤딩은 여러 물리장비에 데이터를 분산하는 방법 MongoDB 는 샤딩을 이용해 매우 큰 데이터에 대해 높은 처리량을 제공
시스템을 확장하는 두 가지 방법  스케일업 스케일아웃(MongoDB 는 샤딩 통해 스케일아웃을 지원)  대상이 되는 자원  CPU 네트워크 메모리 디스크  고려사항 경제적으로 이득인가?
실현가능한가?
예 1)  서버의 CPU 자원에 한계가 다가오고 필요한 CPU 자원은 2배로 예상됨 다음으로 좋은 CPU는 처리량이 10배이고 비용도 10배임 스케일업을 한다면 10배의 비용으로 2배의 CPU만 사용 스케일아웃을 한다면 2배의 비용으로 2배의 CPU 사용가능  예 2)  현재 사용가능한 가장 좋은 CPU를 사용 중 자원에 한계가 다가옴 스케일업으로 해결불가 스케일아웃으로 해결가능  예 3)  디스크를 1TB 에서 20TB 로 20배 스케일업 백업, 복구, resync 에 20배의 시간이 듬 스케일아웃한다면 병렬화의 장점을 사용해 시간을 절약할 수 있음 또 MongoDB의 경우 큰 데이터는 큰 인덱스를 만들기 때문에 메모리 사용량도 함께 증가함  기타 장점 분산처리에 용이하기 때문에 MongoDB 에서 제공하는 존 샤딩, 어그리게이션 등의 기능을 효과적으로 사용가능</description>
    </item>
    
    <item>
      <title>MongoDB 스터디 2주차(MongoDB 설치하기)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-2/</link>
      <pubDate>Sun, 17 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-2/</guid>
      <description>Replica Set Replica set 은 같은 데이터를 가진 mongod 프로세스 그룹입니다. 이를 통해 MongoDB는 데이터 중복과 고가용성을 제공합니다. 그렇기 때문에 일부 서버에 장애가 발생하더라고 전체 시스템은 정상적으로 운영될 수 있습니다.
특정한 경우 복제를 통해 읽기 수용량을 증가시킬 수 있습니다. 또 서로 다른 데이터센터에 복사본을 유지하여 가용성을 증가시킬수 있도 장애복구, 분석, 백업 목적으로 추가 복사본을 만들 수도 있습니다.
Replication Replica set 은 데이터를 가진 여러 노드로 이루어지며(데이터가 없는 아비터가 추가될 수도 있음), 이 중 하나만이 primary 노드가 됩니다.</description>
    </item>
    
    <item>
      <title>MongoDB 스터디 1주차(MongoDB 기초)</title>
      <link>https://marsettler.com/mongodb/mongodb-study-week-1/</link>
      <pubDate>Sun, 10 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://marsettler.com/mongodb/mongodb-study-week-1/</guid>
      <description>들어가며 지금까지 필요 없는 로그성 데이터를 MongoDB에 저장한 경험이 있으며, 대부분은 RDBMS를 사용했습니다. MongoDB도 많이 발전하였고(트랜잭션, 컨시스턴시 관련) 우리의 MongoDB 운영능력도 증가했기 떄문에 애플리케이션에서 스케일아웃을 핸들링하지 않고 MongoDB를 사용해 개발속도를 향상시키고 싶습니다.
MongoDB란 도큐먼트를 기본 자료형으로 사용하는 NoSQL 데이터베이스
도큐먼트와 컬렉션  도큐먼트  도큐먼트는 field와 value의 쌍으로 데이터를 저장하고 관리 JSON 형태로 사용되며 실제로는 BSON으로 시리얼라이즈되어 저장됨    { &amp;#34;name&amp;#34; : &amp;#34;hueypark&amp;#34;, &amp;#34;title&amp;#34; : &amp;#34;software engineer&amp;#34; }  컬렉션  도큐먼트들이 모여있는 집합 일반적으로 한 컬렉션에 있는 도큐먼트들은 공통된 필드를 가지고 있음    BSON BSON은 바이너리로 시리얼라이즈 된 JSON</description>
    </item>
    
  </channel>
</rss>